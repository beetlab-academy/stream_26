import UIKit

//MARK: - Dictionary
//AnyHashable

//Разница между массивом и словарем
//1. Можно испольховать любые ключи, в массиве всегда индексы по порядку
//2. Получение значения из словаря работает значительно быстрее чем из массива
//3. В словаре значения хранятся не по порядку.
//4. Если в массиве обращаемся по несуществующему индексу - Краш, если по несуществующему ключу краша не будет, словарь вернет nil.


//Cложность O(1) - сложность
var dict: [String: Int] = [:] // Инициализация

// Добавление элементов из словаря
dict["пять"] = 5
dict["десять"] = 10
dict["пятнидцать"] = 15
dict["двадцать"] = 20
dict["key"] = 20
print(dict)

//Удаление Элементов из словаря
//dict.removeValue(forKey: "пять")

let num = dict["пять"]
print(num)

for (key, value) in dict {
    print("key - \(key), value \(value)")
}

let array = [1, 2, 3, 6, 8]

for (index, value) in array.enumerated() {
    print("index - \(index), value - \(value)")
}

//MARK: - Задача 1. Есть массив на вход функции. Вернуть нужно словарь где индексы будут ключами, а значения значениями.
let exArray = [12, 14, 16, 18, 20]

func getDict(from array: [Int]) -> [Int: Int] {
    var dict = [Int: Int]()
    for (index, value) in array.enumerated() {
        dict[index] = value
    }
    return dict
}

let indexesDict = getDict(from: exArray)
print(indexesDict)

//MARK: - Задача 2. Есть массив строк на вход функции, Вернуть дикшн где строки ключи а индексы значения.

var array1 = ["first", "second", "third"]
func getDict1(array: [String]) -> [String: Int] {
    var dict: [String: Int] = [:] // объявление пустого слвоаря
    for index in 0...array.count - 1 { // идем от нулевого до последнего индекса в цикле
        let key = array[index] // получаем строку для каждого индекса
        dict[key] = index  // добавляем в словарь по ключу (значение элемента массива по текущему индексу(в данном случае строка))
    }
    return dict //возвращаем словарь из функции
}
let dictResult = getDict1(array: array1)
print(dictResult)

//MARK: Задача 3. На вход функция принимает Int, вернуть дикшинари где по ключю степени в которую возвели этот Int будет лежать значение.
func exponention (x: Int) -> [Int: Int] {
    var dict: [Int: Int] = [:] // создаем пустой словарь, в который будем складывать ключи-значения в соответствии с условиями задачи
    let expArray = [0, 1, 2, 3, 4, 5, 6] // создаем массив степеней
    // для каждого элемента массива нам нужно положить в словарь: key элемент этого массива (степень, в которую будем возводить аргумент), value = x*key
    for index in 0...expArray.count - 1 { // создаем цикл для каждого элемента массива. Выполним код в ()
        let key = expArray[index] // ключ должен быть равен возведенной степени
        let value = pow(Double(x), Double(key)) // значение должно быть равно возведенному числу в степени
        dict[key] = Int(value) // ключ словаря равен значению
    }
    return dict
}

let resultExponention = exponention(x: 5)
print(resultExponention)

//MARK: Задача 4. На вход принимаем массив Имен, массив Фамилий, зная что под одинаковыми индексами Имена и Фамилии соответсвуют(под 0 индексом Фамилия, соответсвует Имени под 0 индексом). Необходимо вернуть словарь где ключ будет индекс массива, а значение правильные Имя и Фамилия. Количество элементов в массиве имен равно количеству элементов в массиве фамилий.
let namesArray = ["Aндрей", "Денис", "Влад"]
let femalesArray = ["Иванов", "Петров", "Сидоров"]

func getFullNameDict(names: [String], females: [String]) -> [Int: String] {
    var dict = [Int: String]()
    for index in 0...namesArray.count - 1 {
        let fullName = names[index] + " " + femalesArray[index]
        dict[index] = fullName
     }
    return dict
    
    //Обьявим словаь с типом [Int: String].
    //Созданим цикл от 0 до последнего индекса любого из массивов потому что они равны(длины массивов)
    //В задаче сказано что ключом словаря должен быть индекс
    //Значение словаря должно быть полное имя которое можно получить names[index] + females[index]
    //положим по ключу наше значение в словарь
    // после цикла вернем словарь
}

let fullNamesResult = getFullNameDict(names: namesArray, females: femalesArray)
print(fullNamesResult)

//MARK: - Set - коллекция
//Set - содержит в себе только уникальные значения

let array13 = [1, 2, 3, 4, 5, 6, 6]

var set = Set<Int>()
set.insert(5)
set.insert(19)
set.insert(5)
print(set)

//MARK: - optional


var optionalNum: Int? // Это значит что optionalNum будет иметь или значение или nil
optionalNum = 5
print(optionalNum)
optionalNum = nil
print(optionalNum)

let dict12 = ["1": 1, "2": 2]
let value: Int = dict12["13"] ?? 435 // Если в dict12["13"] нету такого ключа, то в переменную value запишеться 435
print(optionalNum)


//MARK: - задача с Hackyrank
let socks = [10, 20, 20, 10, 10, 30, 50, 10, 20, 50]

func getCouplesCount(socks: [Int]) -> Int {
    var countOfCouples = 0
    var dict = [Int: String]()

    for sock in socks {
        if dict[sock] != nil {
            //на доске лежит носок такого цвета
            dict[sock] = nil // забираем носок с доски
            countOfCouples += 1 // эквивалентно countOfCouples = countOfCouples + 1
        } else {
            //на доске не лежит насок такого цвета
            dict[sock] = "Любая строка" //Кладем носок на доску
        }
    }
    return countOfCouples
}

let result = getCouplesCount(socks: socks)
print("sockes count -> \(result)")


//MARK: - Optional

var optNum: String?

//Unwrape
//1. ?? - левая часть подставиться в переменную если переменная = nil

var firstUnrappedNum = optNum ?? "Денис"
print(firstUnrappedNum) //Денис
optNum = "Андрей"
var firstUnrappedNum1 = optNum ?? "Денис"
print(firstUnrappedNum1) //Андрей


//2. if let unwrap
if let name = optNum {
    print("Второй способ unwrap - \(name)")
}


//3. guard let unwrap

func someFunc(name: String?) {
    guard let unwrapName = name else { return }
    print(unwrapName)
}


func task3 (z: Int, v: Int) -> Int? {
    if z % 2 != 0 {
        return z
    } else if v % 2 != 0 {
        return v
    } else {
        return nil
    }
}

if let value1 = task3(z: 4, v: 5) {
    print("В аргументы функции был передан хотя бы один нечетный аргумент и это \(value1) ")
} else {
    print("В аргументы функции не было передано ни одного нечетного аргумента")
}

var v3 = task3(z: 3, v: 5)
print(v3)


//Константы
//Переменные
//Функции
//Массивы
//Словари
//Циклы
//if else
//Set
//Optional

//Посмотреть CS50 - первые 2 серии

//MARK: - Задачи:
//1. На вход функции массив целых чисел. Напечатать количество чётных, нечётных, двузначных.
//2. На вход функции массив чисел. Верните этот же массив, но с увеличенными на 10% элементами
//3.Простое число - число, которое делится без остатка на само себя и на 1. Напишите функцию, принимающую на вход целое число и определяющее, простое оно или нет.  ( 7 - простое, 9 - не простое )
//4.Напишите функцию, принимающую на вход массив целых чисел. Используя функцию из задачи 3 верните массив простых чисел из массива. Оценить сложность поиска простых чисел в массиве таким способом
//5.То же, но верните массив не простых чисел.
//6.Напишите функцию, возвращающую среднее арифметическое элементов массива
//7.Есть дикшинари [String: Int] который функция принимает на вход, напишите функцию которая возвращает среднее арифметическое всех Int в словаре.
//8. Есть дикшинари [String: Int] написать функцию которая возвращает массив ключей и функцию которая возвращает массив значений
//9. На вход функции 2 массива. Первый - имена [“Петя”, “Гриша”, “Никола”]. Второй - соответствующие времена пробежки дистанции. [10, 6, 25] (Петя - за 10 минут, Гриша - 6 минут, Никола - 25 минут) . Написать функцию, возвращающую самого медленного и самого быстрого.
//10. На вход функции 2 аргумента - искомое число и массив целых чисел. Вернуть true, если искомое число находится на первом или на последнем месте в массиве
//11. На вход функции массив целых чисел. Вернуть true, если массив длины 1 или у него равны последний и первый элементы
//12.На вход функции 2 массива целых чисел. Вернуть true, если у них одинаковые последние ИЛИ первые элементы. Длина массивов произвольная и не обязательно одинаковая
//13. На вход функции массив целых чисел. Вернуть целое число - разницу между максимальным и минимальным элементом массива
//14. Написать функцию которая принимает на вход 2 массива: первый имен, второй фамилий. Массивы могут быть разной длины, но мы точно знаем что под одинаковыми индексами мы имеем соответствующие имя/фамилию. Вернуть словарь где ключ индекс, значение полное имя. Добавлять в словарь только если есть и имя и фамилия

